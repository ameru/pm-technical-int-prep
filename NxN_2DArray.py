## Given an integer N

## Create an NxN 2D array 
## whose outermost ring is 0
## increment by 1 each successive layer

## Case 1
N = 5
rings = [
  [0,0,0,0,0],
  [0,1,1,1,0],
  [0,1,2,1,0],
  [0,1,1,1,0],
  [0,0,0,0,0],
]

## Case 2
N = 10
rings = [
  [0,0,0,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,0],
  [0,1,2,2,2,2,2,2,1,0],
  [0,1,2,3,3,3,3,2,1,0],
  [0,1,2,3,4,4,3,2,1,0],
  [0,1,2,3,4,4,3,2,1,0],
  [0,1,2,3,3,3,3,2,1,0],
  [0,1,2,2,2,2,2,2,1,0],
  [0,1,1,1,1,1,1,1,1,0],
  [0,0,0,0,0,0,0,0,0,0]
]

# reverse the elements 
# print(lst[::-1])

# slice, combine with negative index
# output of print statement will print all elements, skipping [some #s]
# slice by N/2

# Implementation idea:
# How to dynamically compute each row:
  # for each row
  # count up to midpoint
  # put that in a temporary array that represents the row
  # copy the temporary array, use range (or .reverse()) to reverse temp array
  # add reversed array to original

print(list_1 = [ ])
range(0,(N/2))

ring_23 = [0,1,2,3,3]

for i in range(N):
  midpoint = i/2
  temp_array = [] # first half of the row
  for j in range(0, midpoint):
    temp_array.append(j)
  second_half

def rings(N):
  pass
